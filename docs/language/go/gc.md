# 关于GC
基本上所有现代的语言都会包含GC，毕竟让用户去手动管理内存，大多数用户其实并不具备这样的知识能力。并且其实最好的抽象，其实就是让上游的用户能更聚焦在其业务逻辑上，而不用为这些底层问题去操心。

我们应该以什么样的思路去理解GC？分配在栈上或者是分配在堆上，各种情况是如何取舍的？

## 设计原理
一般分为3个组件，就是用户程序、分配器和收集器

### 分配方法
1. 线性分配器
缺点：
线性分配器无法在内存被释放时重用内存
2. 空闲链表分配器
golang中采用的方式
隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块

线程分配缓存(TCMalloc)是用于分配内存的机制

对象分类：
1. 微对象
2. 小对象
3. 大对象

线程缓存、中心缓存和页堆


## 代码分析
### 片段1
``` go
	slice := make([]int, 1)
	for {
		slice = append(slice, 1)
	}
```
这一段其实是会导致out of memory，
切片（slice）是分配在堆上的，它包含了一个指向底层数组的指针，长度和容量。
数组（array）是分配在栈上的，它是一个固定大小的值类型。
oom不被认为是panic，panic可以看做是Go中的一种内建异常。


## 一些问题
1. 如何减少GC所需的时间
如何减少延时，避免STW，其实也是GC算法一直需要care的点
如何对线上服务做GC监控，我理解是不论对于java或者golang，其实都很难对线上服务直接监控，还是只能去做更为全局的监控


## 参考文档
https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/